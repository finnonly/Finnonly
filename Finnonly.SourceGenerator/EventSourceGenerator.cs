// -
// -
// finnonly@outlook.com
// 2026-01-26
// -
// -

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Finnonly.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class EventSourceGenerator : IIncrementalGenerator
{
    private const string GeneratorName = "VEventHelper";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 修改类型收集逻辑
        var styledElementTypes = context.CompilationProvider.Select((compilation, ct) =>
        {
            var baseType = compilation.GetTypeByMetadataName("Avalonia.StyledElement");
            if (baseType == null) return ImmutableArray<INamedTypeSymbol>.Empty;

            var types = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

            // 1. 优先处理主项目程序集
            CollectTypesFromAssembly(compilation.Assembly, baseType, types, true);

            // 2. 处理引用的程序集
            foreach (var reference in compilation.References)
            {
                var assembly = compilation.GetAssemblyOrModuleSymbol(reference) as IAssemblySymbol;
                if (assembly == null) continue;

                // 仅处理 Avalonia 程序集
                if (assembly.Name.StartsWith("Avalonia", StringComparison.OrdinalIgnoreCase))
                {
                    CollectTypesFromAssembly(assembly, baseType, types, false);
                }
            }

            return types.ToImmutableArray();
        });

        context.RegisterSourceOutput(styledElementTypes, Execute);
    }

    private static void CollectTypesFromAssembly(
        IAssemblySymbol assembly,
        INamedTypeSymbol baseType,
        HashSet<INamedTypeSymbol> results,
        bool isMainAssembly)
    {
        void ProcessNamespace(INamespaceSymbol ns)
        {
            foreach (var member in ns.GetMembers())
            {
                switch (member)
                {
                    case INamespaceSymbol nestedNs:
                        ProcessNamespace(nestedNs);
                        break;

                    case INamedTypeSymbol type:
                        ProcessType(type);
                        break;
                }
            }
        }

        void ProcessType(INamedTypeSymbol type)
        {
            // 检查类型的可访问性和继承关系
            if (ShouldIncludeType(type, baseType, isMainAssembly))
            {
                results.Add(type);
                System.Diagnostics.Debug.WriteLine($"Found type: {type.ToDisplayString()} from assembly: {assembly.Name} (Main: {isMainAssembly})");
            }

            // 处理嵌套类型
            foreach (var nestedType in type.GetTypeMembers())
            {
                ProcessType(nestedType);
            }
        }

        ProcessNamespace(assembly.GlobalNamespace);
    }

    private static bool ShouldIncludeType(INamedTypeSymbol type, INamedTypeSymbol baseType, bool isMainAssembly)
    {
        // 对主项目的类型放宽访问级别限制
        if (isMainAssembly)
        {
            return !type.IsStatic &&
                   !type.IsAbstract &&
                   InheritsFrom(type, baseType);
        }

        // 对引用程序集要求公共访问级别
        return type.DeclaredAccessibility == Accessibility.Public &&
               !type.IsStatic &&
               !type.IsAbstract &&
               InheritsFrom(type, baseType);
    }

    private static bool InheritsFrom(INamedTypeSymbol? type, INamedTypeSymbol baseType)
    {
        var current = type?.BaseType;
        while (current != null)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
                return true;
            current = current.BaseType;
        }

        return false;
    }

    private void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> types)
    {
        if (types.IsDefaultOrEmpty)
        {
            context.AddSource($"{GeneratorName}.Empty.g.cs", GenerateEmptyFile());
            return;
        }

        // 生成详细的调试信息
        GenerateDebugInfo(types, context);

        // 生成主事件助手类
        var sourceBuilder = new StringBuilder();
        GenerateEventBindingHelpers(types, sourceBuilder);
        context.AddSource($"{GeneratorName}.Helpers.g.cs", sourceBuilder.ToString());

        // 为每个类型生成扩展方法
        GenerateTypeExtensions(types, context);
    }

    private string GenerateEmptyFile()
    {
        return $$"""
                 // <auto-generated>
                 // Generated by EventSourceGenerator
                 // Current Date and Time (UTC): {{DateTime.UtcNow:yyyy-MM-dd HH:mm:ss}}
                 // No types found for generation
                 // </auto-generated>
                 namespace Finnonly
                 {
                     internal static class EventSourceGeneratorEmpty
                     {
                         internal const string GeneratedAt = "{{DateTime.UtcNow:yyyy-MM-dd HH:mm:ss}}";
                         internal const string Message = "No types found for generation";
                     }
                 }
                 """;
    }

    private void GenerateTypeExtensions(ImmutableArray<INamedTypeSymbol> types, SourceProductionContext context)
    {
        var processedNames = new HashSet<string>();
        foreach (var type in types)
        {
            var extensionBuilder = new StringBuilder();
            GenerateTypeSpecificExtensions(type, extensionBuilder);

            var baseFileName = GetSafeFileName(type);
            var fileName = baseFileName;
            var counter = 1;

            while (!processedNames.Add(fileName))
            {
                fileName = $"{baseFileName}_{counter++}";
            }

            context.AddSource($"{GeneratorName}.{fileName}.g.cs", extensionBuilder.ToString());
        }
    }

    private void GenerateDebugInfo(ImmutableArray<INamedTypeSymbol> types, SourceProductionContext context)
    {
        var debugInfo = new StringBuilder();
        debugInfo.AppendLine("namespace Finnonly {");
        debugInfo.AppendLine("    internal static class EventSourceGeneratorDebug {");
        debugInfo.AppendLine($"        internal const string GeneratedAt = \"{DateTime.UtcNow:yyyy-MM-dd HH:mm:ss}\";");
        debugInfo.AppendLine("        internal static class TypesFound {");

        // 按程序集分组显示类型
        var typesByAssembly = types.GroupBy(t => t.ContainingAssembly.Name)
            .OrderBy(g => g.Key);

        foreach (var assemblyGroup in typesByAssembly)
        {
            debugInfo.AppendLine($"            // Assembly: {assemblyGroup.Key}");
            foreach (var type in assemblyGroup.OrderBy(t => t.ToDisplayString()))
            {
                var safeName = type.Name.Replace(".", "_").Replace("<", "_").Replace(">", "_");
                debugInfo.AppendLine($"            internal const string {safeName} = \"{type.ToDisplayString()}\";");
            }

            debugInfo.AppendLine();
        }

        debugInfo.AppendLine("        }");
        debugInfo.AppendLine("    }");
        debugInfo.AppendLine("}");

        context.AddSource($"{GeneratorName}.Debug.g.cs", debugInfo.ToString());
    }

    private void GenerateEventBindingHelpers(ImmutableArray<INamedTypeSymbol> types, StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Generated by EventSourceGenerator");
        sb.AppendLine($"// Generated at: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Frozen;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
        sb.AppendLine("using Avalonia.Interactivity;");
        sb.AppendLine("using Avalonia.Controls;");
        sb.AppendLine();
        sb.AppendLine("namespace Finnonly");
        sb.AppendLine("{");
        sb.AppendLine("    file static class EventBindingMetadata");
        sb.AppendLine("    {");
        sb.AppendLine("        public static readonly FrozenDictionary<(Type ElementType, string EventName), Type> EventTypeMap;");
        sb.AppendLine();
        sb.AppendLine("        static EventBindingMetadata()");
        sb.AppendLine("        {");
        sb.AppendLine("            var map = new Dictionary<(Type ElementType, string EventName), Type>()");
        sb.AppendLine("            {");

        foreach (var type in types.OrderBy(t => t.ToDisplayString()))
        {
            var events = GetAllEvents(type);
            var typeWithGlobal = AddGlobalPrefix(type.ToDisplayString());
            foreach (var evt in events)
            {
                sb.AppendLine($"                // From {type.ContainingAssembly.Name}");
                sb.AppendLine($"                [(typeof({typeWithGlobal}), \"{evt.Name}\")] = typeof({evt.Type}),");
            }
        }

        sb.AppendLine("            };");
        sb.AppendLine("            EventTypeMap = map.ToFrozenDictionary();");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static class VEventHelper");
        sb.AppendLine("    {");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        private static bool TryGetEventTypeFromMap(Type type, string eventName, [NotNullWhen(true)] out Type? eventType)");
        sb.AppendLine("        {");
        sb.AppendLine("            while (type != null && type != typeof(object))");
        sb.AppendLine("            {");
        sb.AppendLine("                if (EventBindingMetadata.EventTypeMap.TryGetValue((type, eventName), out eventType))");
        sb.AppendLine("                {");
        sb.AppendLine("                    return true;");
        sb.AppendLine("                }");
        sb.AppendLine("                type = type.BaseType!;");
        sb.AppendLine("            }");
        sb.AppendLine("            eventType = null;");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        public static Type GetEventType(Type elementType, string eventName)");
        sb.AppendLine("        {");
        sb.AppendLine("            ArgumentNullException.ThrowIfNull(elementType);");
        sb.AppendLine("            ArgumentNullException.ThrowIfNull(eventName);");
        sb.AppendLine();
        sb.AppendLine("            if (TryGetEventTypeFromMap(elementType, eventName, out var eventType))");
        sb.AppendLine("            {");
        sb.AppendLine("                return eventType;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            ThrowUnknownEventException(elementType, eventName);");
        sb.AppendLine("            return null!;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("        public static bool HasEvent(Type elementType, string eventName)");
        sb.AppendLine("        {");
        sb.AppendLine("            ArgumentNullException.ThrowIfNull(elementType);");
        sb.AppendLine("            ArgumentNullException.ThrowIfNull(eventName);");
        sb.AppendLine();
        sb.AppendLine("            return TryGetEventTypeFromMap(elementType, eventName, out _);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        [DoesNotReturn]");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.NoInlining)]");
        sb.AppendLine("        private static void ThrowUnknownEventException(Type elementType, string eventName)");
        sb.AppendLine("        {");
        sb.AppendLine("            var availableEvents = new List<string>();");
        sb.AppendLine("            var type = elementType;");
        sb.AppendLine("            while (type != null && type != typeof(object))");
        sb.AppendLine("            {");
        sb.AppendLine("                foreach (var evt in EventBindingMetadata.EventTypeMap.Keys.Where(k => k.ElementType == type))");
        sb.AppendLine("                {");
        sb.AppendLine("                    availableEvents.Add($\"{evt.EventName} (from {evt.ElementType.Name})\");");
        sb.AppendLine("                }");
        sb.AppendLine("                type = type.BaseType!;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            throw new ArgumentException(");
        sb.AppendLine("                $\"Unknown event '{eventName}' for type '{elementType.FullName}'.\\n\" +");
        sb.AppendLine("                \"Available events for this type and its base types:\\n\" +");
        sb.AppendLine("                string.Join(\"\\n\", availableEvents.OrderBy(e => e)));");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public static IEnumerable<(string Name, Type Type)> GetAvailableEvents(Type elementType)");
        sb.AppendLine("        {");
        sb.AppendLine("            ArgumentNullException.ThrowIfNull(elementType);");
        sb.AppendLine();
        sb.AppendLine("            var type = elementType;");
        sb.AppendLine("            while (type != null && type != typeof(object))");
        sb.AppendLine("            {");
        sb.AppendLine("                foreach (var kvp in EventBindingMetadata.EventTypeMap.Where(kvp => kvp.Key.ElementType == type))");
        sb.AppendLine("                {");
        sb.AppendLine("                    yield return (kvp.Key.EventName, kvp.Value);");
        sb.AppendLine("                }");
        sb.AppendLine("                type = type.BaseType!;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        GenerateAOTDelegateFactory(sb, types);
        sb.AppendLine("}");
    }

    private void GenerateAOTDelegateFactory(StringBuilder sb, ImmutableArray<INamedTypeSymbol> types)
    {
        // 收集所有唯一的事件处理器类型及其参数类型信息
        var handlerInfos = new Dictionary<string, EventHandlerInfo>();

        foreach (var type in types)
        {
            foreach (var evt in GetAllEvents(type))
            {
                if (handlerInfos.ContainsKey(evt.Type)) continue;

                var argsType = ExtractEventArgsType(evt.Type);
                var inheritsFromEventArgs = CheckInheritsFromEventArgs(type, argsType);

                handlerInfos[evt.Type] = new EventHandlerInfo
                {
                    HandlerType = evt.Type,
                    ArgsType = argsType,
                    InheritsFromEventArgs = inheritsFromEventArgs
                };
            }
        }

        // 分离继承 EventArgs 和不继承的类型
        var standardHandlers = handlerInfos.Values.Where(h => h.InheritsFromEventArgs).ToList();
        var specialHandlers = handlerInfos.Values.Where(h => !h.InheritsFromEventArgs).ToList();

        sb.AppendLine("""
                      /// <summary>
                      /// AOT-compatible delegate creation helper.
                      /// Replaces reflection-based Delegate.CreateDelegate for Native AOT scenarios.
                      /// </summary>
                      public static class AOTDelegateHelper
                      {
                          /// <summary>
                          /// Creates a delegate for standard EventArgs-based events.
                          /// </summary>
                          [MethodImpl(MethodImplOptions.AggressiveInlining)]
                          public static Delegate CreateDelegateCore(Type handlerType, Action<object?, EventArgs> invoke)
                          {
                      """);

        // 生成标准 EventArgs 继承类型的处理
        foreach (var handler in standardHandlers.OrderBy(h => h.HandlerType))
        {
            var normalizedType = NormalizeTypeName(handler.HandlerType);
            sb.AppendLine($"            if (handlerType == typeof({normalizedType}))");
            sb.AppendLine($"                return new {normalizedType}((sender, e) => invoke(sender, e));");
            sb.AppendLine();
        }

        // 标准 EventHandler
        sb.AppendLine("            if (handlerType == typeof(EventHandler))");
        sb.AppendLine("                return new EventHandler((sender, e) => invoke(sender, e));");
        sb.AppendLine();

        // 对于特殊类型，抛出提示使用专用方法
        if (specialHandlers.Any())
        {
            sb.AppendLine("            // Special types that don't inherit from EventArgs");
            sb.AppendLine("            // Use the type-specific overload methods instead");
            foreach (var handler in specialHandlers.OrderBy(h => h.HandlerType))
            {
                sb.AppendLine($"            if (handlerType == typeof({handler.HandlerType}))");
                sb.AppendLine($"                throw new InvalidOperationException(");
                sb.AppendLine($"                    \"Type '{handler.HandlerType}' does not inherit from EventArgs. \" +");
                sb.AppendLine($"                    \"Use CreateDelegate<{handler.ArgsType}>() overload instead.\");");
                sb.AppendLine();
            }
        }

        sb.AppendLine("""
                              throw new NotSupportedException(
                                  $"No AOT-compatible delegate factory for type '{handlerType.FullName}'.");
                          }
                      """);

        // 生成特殊类型的专用方法
        if (specialHandlers.Any())
        {
            sb.AppendLine();
            sb.AppendLine("        // ========== Special handlers for non-EventArgs types ==========");
            sb.AppendLine();

            foreach (var handler in specialHandlers.OrderBy(h => h.HandlerType))
            {
                var methodName = GetSafeMethodName(handler.ArgsType);
                var argsTypeWithGlobal = AddGlobalPrefix(handler.ArgsType);
                sb.AppendLine($"        /// <summary>");
                sb.AppendLine($"        /// Creates a delegate for {handler.HandlerType} (non-EventArgs type).");
                sb.AppendLine($"        /// </summary>");
                sb.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine($"        public static {handler.HandlerType} Create{methodName}Handler(Action<object?, {argsTypeWithGlobal}> invoke)");
                sb.AppendLine($"        {{");
                sb.AppendLine($"            return new {handler.HandlerType}((sender, e) => invoke(sender, e));");
                sb.AppendLine($"        }}");
                sb.AppendLine();
            }
        }

        // 生成统一的泛型入口方法
        sb.AppendLine("""
                          /// <summary>
                          /// Universal AOT-compatible delegate creation method.
                          /// Handles both EventArgs-derived and special types.
                          /// </summary>
                          [MethodImpl(MethodImplOptions.AggressiveInlining)]
                          public static Delegate CreateDelegateUniversal(
                              Type handlerType, 
                              Action<object?, object?> invoke)
                          {
                      """);

        // 生成所有类型的处理（包括特殊类型）
        foreach (var handler in standardHandlers.Concat(specialHandlers).OrderBy(h => h.HandlerType))
        {
            var normalizedType = NormalizeTypeName(handler.HandlerType);
            sb.AppendLine($"            if (handlerType == typeof({normalizedType}))");
            sb.AppendLine($"                return new {normalizedType}((sender, e) => invoke(sender, e));");
            sb.AppendLine();
        }

        sb.AppendLine("            if (handlerType == typeof(EventHandler))");
        sb.AppendLine("                return new EventHandler((sender, e) => invoke(sender, e));");
        sb.AppendLine();

        sb.AppendLine("""
                              throw new NotSupportedException(
                                  $"No AOT-compatible delegate factory for type '{handlerType.FullName}'.");
                          }
                      }
                      """);
        
        // 生成 ModuleInitializer 来初始化 EventBindProvider
        GenerateModuleInitializer(sb);
    }

    private void GenerateModuleInitializer(StringBuilder sb)
    {
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Module initializer to register event binding services with EventBindProvider.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    file static class EventBindingInitializer");
        sb.AppendLine("    {");
        sb.AppendLine("        [System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("        internal static void Initialize()");
        sb.AppendLine("        {");
        sb.AppendLine("            Finnonly.Avalonia.EventBindProvider.InvokeMethod = MethodDispatcher.Invoke;");
        sb.AppendLine("            Finnonly.Avalonia.EventBindProvider.GetEventType = VEventHelper.GetEventType;");
        sb.AppendLine("            Finnonly.Avalonia.EventBindProvider.CreateDelegate = AOTDelegateHelper.CreateDelegateUniversal;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private class EventHandlerInfo
    {
        public string HandlerType { get; set; } = "";
        public string ArgsType { get; set; } = "";
        public bool InheritsFromEventArgs { get; set; }
    }

    private static string ExtractEventArgsType(string handlerType)
    {
        // 移除 global:: 前缀以便匹配
        var cleanHandlerType = handlerType.Replace("global::", "");
        
        // EventHandler<TEventArgs> -> TEventArgs
        // Action<object?, T> -> T
        var match = System.Text.RegularExpressions.Regex.Match(
            cleanHandlerType,
            @"EventHandler<(.+)>$");

        if (match.Success)
            return match.Groups[1].Value;

        // 处理 Action 类型
        var actionMatch = System.Text.RegularExpressions.Regex.Match(
            cleanHandlerType,
            @"Action<[^,]+,\s*(.+)>$");

        return actionMatch.Success ? actionMatch.Groups[1].Value : "System.EventArgs";
    }

    private bool CheckInheritsFromEventArgs(INamedTypeSymbol contextType, string argsTypeName)
    {
        // 移除 global:: 前缀以便匹配
        var cleanArgsTypeName = argsTypeName.Replace("global::", "");
        
        // 已知继承自 EventArgs 的类型
        var knownEventArgsTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "System.EventArgs",
            "EventArgs",
            "Avalonia.Interactivity.RoutedEventArgs",
            "RoutedEventArgs"
        };

        if (knownEventArgsTypes.Contains(cleanArgsTypeName))
            return true;

        // 已知不继承自 EventArgs 的特殊类型
        var knownNonEventArgsTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "Avalonia.Controls.DatePickerSelectedValueChangedEventArgs",
            "DatePickerSelectedValueChangedEventArgs",
            "Avalonia.Controls.TimePickerSelectedValueChangedEventArgs",
            "TimePickerSelectedValueChangedEventArgs",
            "Avalonia.Input.KeyModifiers",
            "KeyModifiers"
        };

        if (knownNonEventArgsTypes.Contains(cleanArgsTypeName))
            return false;

        // 默认假设继承自 EventArgs（大多数情况）
        // 如果需要更精确，可以通过编译器解析类型继承关系
        return true;
    }

    private static string GetSafeMethodName(string typeName)
    {
        // Avalonia.Controls.DatePickerSelectedValueChangedEventArgs -> DatePickerSelectedValueChanged
        var name = typeName.Split('.').Last();

        // 移除常见后缀
        if (name.EndsWith("EventArgs"))
            name = name.Substring(0, name.Length - "EventArgs".Length);

        return name;
    }

    private static string NormalizeTypeName(string typeName)
    {
        // 移除 global:: 前缀然后重新添加正确的前缀
        var clean = typeName.Replace("global::", "").Trim();
        return AddGlobalPrefix(clean);
    }

    private void GenerateTypeSpecificExtensions(INamedTypeSymbol type, StringBuilder sb)
    {
        var typeFullName = type.ToDisplayString();
        // 为 Avalonia 类型添加 global:: 前缀
        var typeFullNameWithGlobal = AddGlobalPrefix(typeFullName);
        var events = GetAllEvents(type);
        var className = GetExtensionClassName(type);

        sb.AppendLine($$"""
                        // <auto-generated>
                        // Generated by EventSourceGenerator
                        // Generated at: {{DateTime.UtcNow:yyyy-MM-dd HH:mm:ss}} UTC
                        // Type: {{typeFullName}}
                        // </auto-generated>
                        #nullable enable
                        using System;
                        using Avalonia.Interactivity;
                        using Avalonia.Controls;

                        namespace Finnonly
                        {
                            [System.Runtime.CompilerServices.CompilerGenerated]
                            public static class {{className}}
                            {
                        """);

        foreach (var evt in events)
        {
            sb.AppendLine($$"""
                                    /// <summary>
                                    /// Gets the event type for the {{evt.Name}} event of {{type.Name}}.
                                    /// </summary>
                                    public static global::System.Type Get{{evt.Name}}EventType(this {{typeFullNameWithGlobal}} _) => typeof({{evt.Type}});

                            """);
        }

        sb.AppendLine("""
                          }
                      }
                      """);
    }

    private void GenerateAOTDelegateCreationHelpers(StringBuilder sb)
    {
        sb.AppendLine("""
                      /// <summary>
                      /// AOT-compatible delegate factory registry.
                      /// </summary>
                      file static class AOTDelegateFactory
                      {
                          private static readonly FrozenDictionary<Type, Func<object, Delegate>> DelegateFactories;

                          static AOTDelegateFactory()
                          {
                              var factories = new Dictionary<Type, Func<object, Delegate>>()
                              {
                                  // EventHandler
                                  [typeof(EventHandler)] = target => 
                                      new EventHandler(((IEventInvoker)target).Invoke),
                                  
                                  // EventHandler<T> for common event args types
                                  [typeof(EventHandler<EventArgs>)] = target => 
                                      new EventHandler<EventArgs>(((IEventInvoker<EventArgs>)target).Invoke),
                                  
                                  [typeof(EventHandler<RoutedEventArgs>)] = target => 
                                      new EventHandler<RoutedEventArgs>(((IEventInvoker<RoutedEventArgs>)target).Invoke),
                                  
                                  [typeof(EventHandler<PointerPressedEventArgs>)] = target => 
                                      new EventHandler<PointerPressedEventArgs>(((IEventInvoker<PointerPressedEventArgs>)target).Invoke),
                                  
                                  [typeof(EventHandler<PointerReleasedEventArgs>)] = target => 
                                      new EventHandler<PointerReleasedEventArgs>(((IEventInvoker<PointerReleasedEventArgs>)target).Invoke),
                                  
                                  [typeof(EventHandler<PointerMovedEventArgs>)] = target => 
                                      new EventHandler<PointerMovedEventArgs>(((IEventInvoker<PointerMovedEventArgs>)target).Invoke),
                                  
                                  [typeof(EventHandler<KeyEventArgs>)] = target => 
                                      new EventHandler<KeyEventArgs>(((IEventInvoker<KeyEventArgs>)target).Invoke),
                                  
                                  [typeof(EventHandler<TextInputEventArgs>)] = target => 
                                      new EventHandler<TextInputEventArgs>(((IEventInvoker<TextInputEventArgs>)target).Invoke),
                                  
                                  // Add more event types as needed
                              };
                              DelegateFactories = factories.ToFrozenDictionary();
                          }

                          [MethodImpl(MethodImplOptions.AggressiveInlining)]
                          public static bool TryCreateDelegate(Type handlerType, object target, [NotNullWhen(true)] out Delegate? result)
                          {
                              if (DelegateFactories.TryGetValue(handlerType, out var factory))
                              {
                                  result = factory(target);
                                  return true;
                              }
                              result = null;
                              return false;
                          }
                      }

                      /// <summary>
                      /// Interface for AOT-compatible event invocation.
                      /// </summary>
                      public interface IEventInvoker
                      {
                          void Invoke(object? sender, EventArgs e);
                      }

                      /// <summary>
                      /// Generic interface for AOT-compatible typed event invocation.
                      /// </summary>
                      public interface IEventInvoker<TEventArgs> where TEventArgs : EventArgs
                      {
                          void Invoke(object? sender, TEventArgs e);
                      }

                      /// <summary>
                      /// AOT-compatible delegate creation helper.
                      /// </summary>
                      public static class AOTDelegateHelper
                      {
                          /// <summary>
                          /// Creates a delegate in an AOT-compatible way.
                          /// Falls back to reflection-based creation if no AOT factory is registered.
                          /// </summary>
                          /// <param name="handlerType">The delegate type to create.</param>
                          /// <param name="target">The target object containing the Invoke method.</param>
                          /// <returns>The created delegate.</returns>
                          [MethodImpl(MethodImplOptions.AggressiveInlining)]
                          public static Delegate CreateDelegate(Type handlerType, object target)
                          {
                              ArgumentNullException.ThrowIfNull(handlerType);
                              ArgumentNullException.ThrowIfNull(target);

                              // Try AOT-friendly path first
                              if (AOTDelegateFactory.TryCreateDelegate(handlerType, target, out var result))
                              {
                                  return result;
                              }

                              // Fallback for non-AOT scenarios (will throw in true AOT environment)
                              return CreateDelegateFallback(handlerType, target);
                          }

                          [MethodImpl(MethodImplOptions.NoInlining)]
                          private static Delegate CreateDelegateFallback(Type handlerType, object target)
                          {
                              var invokeMethod = target.GetType().GetMethod(
                                  "Invoke",
                                  System.Reflection.BindingFlags.Instance |
                                  System.Reflection.BindingFlags.NonPublic |
                                  System.Reflection.BindingFlags.Public);

                              if (invokeMethod == null)
                              {
                                  throw new InvalidOperationException(
                                      $"Target type '{target.GetType().FullName}' does not have an Invoke method.");
                              }

                              return Delegate.CreateDelegate(handlerType, target, invokeMethod);
                          }

                          /// <summary>
                          /// Creates a delegate for the specified event type in an AOT-compatible way.
                          /// </summary>
                          [MethodImpl(MethodImplOptions.AggressiveInlining)]
                          public static Delegate CreateDelegateForEvent<TTarget, TEventArgs>(
                              TTarget target,
                              Action<TTarget, object?, TEventArgs> invokeAction)
                              where TTarget : class
                              where TEventArgs : EventArgs
                          {
                              return new EventHandler<TEventArgs>((sender, e) => invokeAction(target, sender, e));
                          }

                          /// <summary>
                          /// Creates a generic EventHandler delegate in an AOT-compatible way.
                          /// </summary>
                          [MethodImpl(MethodImplOptions.AggressiveInlining)]
                          public static EventHandler<TEventArgs> CreateEventHandler<TEventArgs>(
                              Action<object?, TEventArgs> handler)
                              where TEventArgs : EventArgs
                          {
                              return new EventHandler<TEventArgs>(handler.Invoke);
                          }
                      }
                      """);
    }

    private static string GetExtensionClassName(INamedTypeSymbol type)
    {
        // 创建唯一的类名
        var nameBuilder = new StringBuilder();
        var current = type;

        while (current != null)
        {
            if (nameBuilder.Length > 0)
            {
                nameBuilder.Insert(0, "_");
            }

            nameBuilder.Insert(0, current.Name);
            current = current.ContainingType;
        }

        // 添加命名空间的哈希以确保唯一性
        var namespaceHash = type.ContainingNamespace?.ToString()?.GetHashCode() ?? 0;
        var safeHash = Math.Abs(namespaceHash).ToString("X4");

        return $"{nameBuilder}_Events_{safeHash}";
    }

    private static string GetSafeFileName(INamedTypeSymbol type)
    {
        // 获取完整的类型名称，包括所有嵌套类型
        var fullName = new StringBuilder();
        var current = type;

        while (current != null)
        {
            if (fullName.Length > 0)
            {
                fullName.Insert(0, "_");
            }

            fullName.Insert(0, current.Name);
            current = current.ContainingType;
        }

        // 添加命名空间的哈希值以确保唯一性
        var namespaceHash = type.ContainingNamespace?.ToString()?.GetHashCode() ?? 0;
        var safeHash = Math.Abs(namespaceHash).ToString("X8");

        return $"Extensions_{fullName}_{safeHash}";
    }

    private static IEnumerable<(string Name, string Type)> GetAllEvents(INamedTypeSymbol type)
    {
        var events = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        // 对主项目类型放宽访问级别限制
        var isMainAssembly = !type.ContainingAssembly.Name.StartsWith("Avalonia");
        foreach (var member in type.GetMembers().OfType<IEventSymbol>())
        {
            if (!isMainAssembly && member.DeclaredAccessibility != Accessibility.Public) continue;
            var eventType = member.Type.ToDisplayString(new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                miscellaneousOptions: SymbolDisplayMiscellaneousOptions.None));

            // 为 Avalonia 类型添加 global:: 前缀以避免命名空间冲突
            eventType = AddGlobalPrefix(eventType);
            events[member.Name] = eventType;
        }

        return events.Select(kvp => (kvp.Key, kvp.Value));
    }

    /// <summary>
    /// 为 Avalonia 命名空间添加 global:: 前缀以避免命名空间冲突
    /// </summary>
    private static string AddGlobalPrefix(string typeName)
    {
        // 处理 EventHandler<T> 等泛型类型
        if (typeName.StartsWith("System.EventHandler<"))
        {
            var innerType = typeName.Substring("System.EventHandler<".Length, typeName.Length - "System.EventHandler<".Length - 1);
            innerType = AddGlobalPrefix(innerType);
            return $"global::System.EventHandler<{innerType}>";
        }

        if (typeName.StartsWith("Avalonia."))
        {
            return "global::" + typeName;
        }

        if (typeName.StartsWith("System."))
        {
            return "global::" + typeName;
        }

        return typeName;
    }
}
