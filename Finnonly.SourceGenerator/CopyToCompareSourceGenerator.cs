// -
// -
// finnonly@outlook.com
// 2026-01-26
// -
// -

using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Finnonly.SourceGenerator;

[Generator]
public class CopyToCompareSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Filter classes with CopyToAttribute or CompareAttribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)
            .Select(static (m, _) => m!);

        // Combine with compilation
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static ClassInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // 修复：强制转换为 INamedTypeSymbol
        var declaredSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
        if (declaredSymbol is not INamedTypeSymbol classSymbol)
            return null;

        bool hasCopyTo = false;
        bool hasCompare = false;

        foreach (var attribute in classSymbol.GetAttributes())
        {
            var attributeName = attribute.AttributeClass?.Name;
            if (attributeName == "CopyToAttribute")
                hasCopyTo = true;
            else if (attributeName == "CompareAttribute")
                hasCompare = true;
        }

        if (!hasCopyTo && !hasCompare) return null;

        // Get all properties
        var properties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.CanBeReferencedByName &&
                        p.GetMethod != null &&
                        p.SetMethod != null &&
                        p.SetMethod.DeclaredAccessibility == Accessibility.Public)
            .Select(p => new PropertyInfo(p.Name, p.Type.ToDisplayString()))
            .ToImmutableArray();

        return new ClassInfo(
            classSymbol.Name,
            GetNamespace(classSymbol),
            hasCopyTo,
            hasCompare,
            properties);
    }

    private static string GetNamespace(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace?.ToDisplayString();
        return string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>"
            ? string.Empty
            : namespaceName ?? string.Empty;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassInfo> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty) return;

        foreach (var classInfo in classes)
        {
            if (classInfo == null) continue;

            var source = GenerateSource(classInfo);
            context.AddSource($"{classInfo.ClassName}.g.cs", source);
        }
    }

    private static string GenerateSource(ClassInfo classInfo)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(classInfo.Namespace))
        {
            sb.AppendLine($"namespace {classInfo.Namespace}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"    public partial class {classInfo.ClassName}");
        sb.AppendLine("    {");

        // Generate CopyTo method
        if (classInfo.HasCopyTo)
        {
            GenerateCopyToMethod(sb, classInfo);
        }

        // Generate Compare method
        if (classInfo.HasCompare)
        {
            GenerateCompareMethod(sb, classInfo);
        }

        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(classInfo.Namespace))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static void GenerateCopyToMethod(StringBuilder sb, ClassInfo classInfo)
    {
        sb.AppendLine($"        public void CopyTo({classInfo.ClassName} target)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (target == null)");
        sb.AppendLine("                throw new ArgumentNullException(nameof(target));");
        sb.AppendLine();

        foreach (var property in classInfo.Properties)
        {
            sb.AppendLine($"            target.{property.Name} = this.{property.Name};");
        }

        sb.AppendLine("        }");
        sb.AppendLine();

        // Also generate a generic CopyTo method
        sb.AppendLine($"        public T CopyTo<T>() where T : {classInfo.ClassName}, new()");
        sb.AppendLine("        {");
        sb.AppendLine("            var target = new T();");
        sb.AppendLine("            CopyTo(target);");
        sb.AppendLine("            return target;");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateCompareMethod(StringBuilder sb, ClassInfo classInfo)
    {
        sb.AppendLine($"        public bool Compare({classInfo.ClassName} other)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (other == null)");
        sb.AppendLine("                return false;");
        sb.AppendLine();
        sb.AppendLine("            if (ReferenceEquals(this, other))");
        sb.AppendLine("                return true;");
        sb.AppendLine();

        if (classInfo.Properties.Any())
        {
            sb.AppendLine("            return");

            for (int i = 0; i < classInfo.Properties.Length; i++)
            {
                var property = classInfo.Properties[i];
                var comparison = GetComparisonExpression(property);

                if (i == classInfo.Properties.Length - 1)
                {
                    sb.AppendLine($"                {comparison};");
                }
                else
                {
                    sb.AppendLine($"                {comparison} &&");
                }
            }
        }
        else
        {
            sb.AppendLine("            return true;");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string GetComparisonExpression(PropertyInfo property)
    {
        // Handle different types of comparison
        if (IsNullableValueType(property.TypeName) || IsReferenceType(property.TypeName))
        {
            return $"Equals(this.{property.Name}, other.{property.Name})";
        }
        else
        {
            return $"this.{property.Name}.Equals(other.{property.Name})";
        }
    }

    private static bool IsNullableValueType(string typeName)
    {
        return typeName.Contains("?") || typeName.StartsWith("System.Nullable<");
    }

    private static bool IsReferenceType(string typeName)
    {
        // Simple heuristic - in a real implementation you'd use semantic analysis
        return typeName == "string" ||
               typeName.Contains("[]") ||
               (!typeName.Contains("int") &&
                !typeName.Contains("bool") &&
                !typeName.Contains("double") &&
                !typeName.Contains("float") &&
                !typeName.Contains("decimal") &&
                !typeName.Contains("DateTime") &&
                !typeName.Contains("Guid") &&
                !typeName.EndsWith("?"));
    }

    // 传统类代替 record
    public class ClassInfo
    {
        public string ClassName { get; }
        public string Namespace { get; }
        public bool HasCopyTo { get; }
        public bool HasCompare { get; }
        public ImmutableArray<PropertyInfo> Properties { get; }

        public ClassInfo(string className, string @namespace, bool hasCopyTo, bool hasCompare, ImmutableArray<PropertyInfo> properties)
        {
            ClassName = className;
            Namespace = @namespace;
            HasCopyTo = hasCopyTo;
            HasCompare = hasCompare;
            Properties = properties;
        }
    }

    // 传统类代替 record
    public class PropertyInfo
    {
        public string Name { get; }
        public string TypeName { get; }

        public PropertyInfo(string name, string typeName)
        {
            Name = name;
            TypeName = typeName;
        }
    }
}
